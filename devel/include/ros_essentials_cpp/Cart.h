// Generated by gencpp from file ros_essentials_cpp/Cart.msg
// DO NOT EDIT!


#ifndef ROS_ESSENTIALS_CPP_MESSAGE_CART_H
#define ROS_ESSENTIALS_CPP_MESSAGE_CART_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace ros_essentials_cpp
{
template <class ContainerAllocator>
struct Cart_
{
  typedef Cart_<ContainerAllocator> Type;

  Cart_()
    : motor1Speed(0.0)
    , motor2Speed(0.0)
    , motor3Speed(0.0)
    , motor4Speed(0.0)
    , motor1Error(false)
    , motor2Error(false)
    , motor3Error(false)
    , motor4Error(false)
    , motor1PWM(0.0)
    , motor2PWM(0.0)
    , motor3PWM(0.0)
    , motor4PWM(0.0)
    , motor1Overcurrent(false)
    , motor2Overcurrent(false)
    , motor3Overcurrent(false)
    , motor4Overcurrent(false)
    , sensor1(false)
    , sensor2(false)
    , sensor3(false)
    , sensor4(false)
    , sensor5(false)
    , sensor6(false)
    , sensor7(false)
    , sensor8(false)
    , relay1(false)
    , relay2(false)
    , relay3(false)
    , relay4(false)
    , relay5(false)
    , relay6(false)
    , relay7(false)
    , relay8(false)
    , relay1Error(false)
    , relay2Error(false)
    , relay3Error(false)
    , relay4Error(false)
    , relay5Error(false)
    , relay6Error(false)
    , relay7Error(false)
    , relay8Error(false)
    , servoMotor1(false)
    , servoMotor2(false)
    , servoMotor3(false)
    , servoMotor4(false)
    , mixingCamera(0)  {
    }
  Cart_(const ContainerAllocator& _alloc)
    : motor1Speed(0.0)
    , motor2Speed(0.0)
    , motor3Speed(0.0)
    , motor4Speed(0.0)
    , motor1Error(false)
    , motor2Error(false)
    , motor3Error(false)
    , motor4Error(false)
    , motor1PWM(0.0)
    , motor2PWM(0.0)
    , motor3PWM(0.0)
    , motor4PWM(0.0)
    , motor1Overcurrent(false)
    , motor2Overcurrent(false)
    , motor3Overcurrent(false)
    , motor4Overcurrent(false)
    , sensor1(false)
    , sensor2(false)
    , sensor3(false)
    , sensor4(false)
    , sensor5(false)
    , sensor6(false)
    , sensor7(false)
    , sensor8(false)
    , relay1(false)
    , relay2(false)
    , relay3(false)
    , relay4(false)
    , relay5(false)
    , relay6(false)
    , relay7(false)
    , relay8(false)
    , relay1Error(false)
    , relay2Error(false)
    , relay3Error(false)
    , relay4Error(false)
    , relay5Error(false)
    , relay6Error(false)
    , relay7Error(false)
    , relay8Error(false)
    , servoMotor1(false)
    , servoMotor2(false)
    , servoMotor3(false)
    , servoMotor4(false)
    , mixingCamera(0)  {
  (void)_alloc;
    }



   typedef float _motor1Speed_type;
  _motor1Speed_type motor1Speed;

   typedef float _motor2Speed_type;
  _motor2Speed_type motor2Speed;

   typedef float _motor3Speed_type;
  _motor3Speed_type motor3Speed;

   typedef float _motor4Speed_type;
  _motor4Speed_type motor4Speed;

   typedef uint8_t _motor1Error_type;
  _motor1Error_type motor1Error;

   typedef uint8_t _motor2Error_type;
  _motor2Error_type motor2Error;

   typedef uint8_t _motor3Error_type;
  _motor3Error_type motor3Error;

   typedef uint8_t _motor4Error_type;
  _motor4Error_type motor4Error;

   typedef float _motor1PWM_type;
  _motor1PWM_type motor1PWM;

   typedef float _motor2PWM_type;
  _motor2PWM_type motor2PWM;

   typedef float _motor3PWM_type;
  _motor3PWM_type motor3PWM;

   typedef float _motor4PWM_type;
  _motor4PWM_type motor4PWM;

   typedef uint8_t _motor1Overcurrent_type;
  _motor1Overcurrent_type motor1Overcurrent;

   typedef uint8_t _motor2Overcurrent_type;
  _motor2Overcurrent_type motor2Overcurrent;

   typedef uint8_t _motor3Overcurrent_type;
  _motor3Overcurrent_type motor3Overcurrent;

   typedef uint8_t _motor4Overcurrent_type;
  _motor4Overcurrent_type motor4Overcurrent;

   typedef uint8_t _sensor1_type;
  _sensor1_type sensor1;

   typedef uint8_t _sensor2_type;
  _sensor2_type sensor2;

   typedef uint8_t _sensor3_type;
  _sensor3_type sensor3;

   typedef uint8_t _sensor4_type;
  _sensor4_type sensor4;

   typedef uint8_t _sensor5_type;
  _sensor5_type sensor5;

   typedef uint8_t _sensor6_type;
  _sensor6_type sensor6;

   typedef uint8_t _sensor7_type;
  _sensor7_type sensor7;

   typedef uint8_t _sensor8_type;
  _sensor8_type sensor8;

   typedef uint8_t _relay1_type;
  _relay1_type relay1;

   typedef uint8_t _relay2_type;
  _relay2_type relay2;

   typedef uint8_t _relay3_type;
  _relay3_type relay3;

   typedef uint8_t _relay4_type;
  _relay4_type relay4;

   typedef uint8_t _relay5_type;
  _relay5_type relay5;

   typedef uint8_t _relay6_type;
  _relay6_type relay6;

   typedef uint8_t _relay7_type;
  _relay7_type relay7;

   typedef uint8_t _relay8_type;
  _relay8_type relay8;

   typedef uint8_t _relay1Error_type;
  _relay1Error_type relay1Error;

   typedef uint8_t _relay2Error_type;
  _relay2Error_type relay2Error;

   typedef uint8_t _relay3Error_type;
  _relay3Error_type relay3Error;

   typedef uint8_t _relay4Error_type;
  _relay4Error_type relay4Error;

   typedef uint8_t _relay5Error_type;
  _relay5Error_type relay5Error;

   typedef uint8_t _relay6Error_type;
  _relay6Error_type relay6Error;

   typedef uint8_t _relay7Error_type;
  _relay7Error_type relay7Error;

   typedef uint8_t _relay8Error_type;
  _relay8Error_type relay8Error;

   typedef uint8_t _servoMotor1_type;
  _servoMotor1_type servoMotor1;

   typedef uint8_t _servoMotor2_type;
  _servoMotor2_type servoMotor2;

   typedef uint8_t _servoMotor3_type;
  _servoMotor3_type servoMotor3;

   typedef uint8_t _servoMotor4_type;
  _servoMotor4_type servoMotor4;

   typedef int8_t _mixingCamera_type;
  _mixingCamera_type mixingCamera;





  typedef boost::shared_ptr< ::ros_essentials_cpp::Cart_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::ros_essentials_cpp::Cart_<ContainerAllocator> const> ConstPtr;

}; // struct Cart_

typedef ::ros_essentials_cpp::Cart_<std::allocator<void> > Cart;

typedef boost::shared_ptr< ::ros_essentials_cpp::Cart > CartPtr;
typedef boost::shared_ptr< ::ros_essentials_cpp::Cart const> CartConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::ros_essentials_cpp::Cart_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::ros_essentials_cpp::Cart_<ContainerAllocator> >::stream(s, "", v);
return s;
}

} // namespace ros_essentials_cpp

namespace ros
{
namespace message_traits
{



// BOOLTRAITS {'IsFixedSize': True, 'IsMessage': True, 'HasHeader': False}
// {'std_msgs': ['/opt/ros/melodic/share/std_msgs/cmake/../msg'], 'actionlib_msgs': ['/opt/ros/melodic/share/actionlib_msgs/cmake/../msg'], 'ros_essentials_cpp': ['/home/xy/catkin_ws/src/ros_essentials_cpp/msg', '/home/xy/catkin_ws/devel/share/ros_essentials_cpp/msg']}

// !!!!!!!!!!! ['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_parsed_fields', 'constants', 'fields', 'full_name', 'has_header', 'header_present', 'names', 'package', 'parsed_fields', 'short_name', 'text', 'types']




template <class ContainerAllocator>
struct IsFixedSize< ::ros_essentials_cpp::Cart_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::ros_essentials_cpp::Cart_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::ros_essentials_cpp::Cart_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::ros_essentials_cpp::Cart_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::ros_essentials_cpp::Cart_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::ros_essentials_cpp::Cart_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::ros_essentials_cpp::Cart_<ContainerAllocator> >
{
  static const char* value()
  {
    return "776fd6e482fa89410df61d8ea2f4d06a";
  }

  static const char* value(const ::ros_essentials_cpp::Cart_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x776fd6e482fa8941ULL;
  static const uint64_t static_value2 = 0x0df61d8ea2f4d06aULL;
};

template<class ContainerAllocator>
struct DataType< ::ros_essentials_cpp::Cart_<ContainerAllocator> >
{
  static const char* value()
  {
    return "ros_essentials_cpp/Cart";
  }

  static const char* value(const ::ros_essentials_cpp::Cart_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::ros_essentials_cpp::Cart_<ContainerAllocator> >
{
  static const char* value()
  {
    return "float32 motor1Speed\n"
"float32 motor2Speed\n"
"float32 motor3Speed\n"
"float32 motor4Speed\n"
"bool motor1Error\n"
"bool motor2Error\n"
"bool motor3Error\n"
"bool motor4Error\n"
"float32 motor1PWM\n"
"float32 motor2PWM\n"
"float32 motor3PWM\n"
"float32 motor4PWM\n"
"bool motor1Overcurrent\n"
"bool motor2Overcurrent\n"
"bool motor3Overcurrent\n"
"bool motor4Overcurrent\n"
"bool sensor1\n"
"bool sensor2\n"
"bool sensor3\n"
"bool sensor4\n"
"bool sensor5\n"
"bool sensor6\n"
"bool sensor7\n"
"bool sensor8\n"
"bool relay1\n"
"bool relay2\n"
"bool relay3\n"
"bool relay4\n"
"bool relay5\n"
"bool relay6\n"
"bool relay7\n"
"bool relay8\n"
"bool relay1Error\n"
"bool relay2Error\n"
"bool relay3Error\n"
"bool relay4Error\n"
"bool relay5Error\n"
"bool relay6Error\n"
"bool relay7Error\n"
"bool relay8Error\n"
"bool servoMotor1\n"
"bool servoMotor2\n"
"bool servoMotor3\n"
"bool servoMotor4\n"
"int8 mixingCamera\n"
"\n"
;
  }

  static const char* value(const ::ros_essentials_cpp::Cart_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::ros_essentials_cpp::Cart_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.motor1Speed);
      stream.next(m.motor2Speed);
      stream.next(m.motor3Speed);
      stream.next(m.motor4Speed);
      stream.next(m.motor1Error);
      stream.next(m.motor2Error);
      stream.next(m.motor3Error);
      stream.next(m.motor4Error);
      stream.next(m.motor1PWM);
      stream.next(m.motor2PWM);
      stream.next(m.motor3PWM);
      stream.next(m.motor4PWM);
      stream.next(m.motor1Overcurrent);
      stream.next(m.motor2Overcurrent);
      stream.next(m.motor3Overcurrent);
      stream.next(m.motor4Overcurrent);
      stream.next(m.sensor1);
      stream.next(m.sensor2);
      stream.next(m.sensor3);
      stream.next(m.sensor4);
      stream.next(m.sensor5);
      stream.next(m.sensor6);
      stream.next(m.sensor7);
      stream.next(m.sensor8);
      stream.next(m.relay1);
      stream.next(m.relay2);
      stream.next(m.relay3);
      stream.next(m.relay4);
      stream.next(m.relay5);
      stream.next(m.relay6);
      stream.next(m.relay7);
      stream.next(m.relay8);
      stream.next(m.relay1Error);
      stream.next(m.relay2Error);
      stream.next(m.relay3Error);
      stream.next(m.relay4Error);
      stream.next(m.relay5Error);
      stream.next(m.relay6Error);
      stream.next(m.relay7Error);
      stream.next(m.relay8Error);
      stream.next(m.servoMotor1);
      stream.next(m.servoMotor2);
      stream.next(m.servoMotor3);
      stream.next(m.servoMotor4);
      stream.next(m.mixingCamera);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct Cart_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::ros_essentials_cpp::Cart_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::ros_essentials_cpp::Cart_<ContainerAllocator>& v)
  {
    s << indent << "motor1Speed: ";
    Printer<float>::stream(s, indent + "  ", v.motor1Speed);
    s << indent << "motor2Speed: ";
    Printer<float>::stream(s, indent + "  ", v.motor2Speed);
    s << indent << "motor3Speed: ";
    Printer<float>::stream(s, indent + "  ", v.motor3Speed);
    s << indent << "motor4Speed: ";
    Printer<float>::stream(s, indent + "  ", v.motor4Speed);
    s << indent << "motor1Error: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.motor1Error);
    s << indent << "motor2Error: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.motor2Error);
    s << indent << "motor3Error: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.motor3Error);
    s << indent << "motor4Error: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.motor4Error);
    s << indent << "motor1PWM: ";
    Printer<float>::stream(s, indent + "  ", v.motor1PWM);
    s << indent << "motor2PWM: ";
    Printer<float>::stream(s, indent + "  ", v.motor2PWM);
    s << indent << "motor3PWM: ";
    Printer<float>::stream(s, indent + "  ", v.motor3PWM);
    s << indent << "motor4PWM: ";
    Printer<float>::stream(s, indent + "  ", v.motor4PWM);
    s << indent << "motor1Overcurrent: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.motor1Overcurrent);
    s << indent << "motor2Overcurrent: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.motor2Overcurrent);
    s << indent << "motor3Overcurrent: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.motor3Overcurrent);
    s << indent << "motor4Overcurrent: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.motor4Overcurrent);
    s << indent << "sensor1: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.sensor1);
    s << indent << "sensor2: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.sensor2);
    s << indent << "sensor3: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.sensor3);
    s << indent << "sensor4: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.sensor4);
    s << indent << "sensor5: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.sensor5);
    s << indent << "sensor6: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.sensor6);
    s << indent << "sensor7: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.sensor7);
    s << indent << "sensor8: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.sensor8);
    s << indent << "relay1: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.relay1);
    s << indent << "relay2: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.relay2);
    s << indent << "relay3: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.relay3);
    s << indent << "relay4: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.relay4);
    s << indent << "relay5: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.relay5);
    s << indent << "relay6: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.relay6);
    s << indent << "relay7: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.relay7);
    s << indent << "relay8: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.relay8);
    s << indent << "relay1Error: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.relay1Error);
    s << indent << "relay2Error: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.relay2Error);
    s << indent << "relay3Error: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.relay3Error);
    s << indent << "relay4Error: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.relay4Error);
    s << indent << "relay5Error: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.relay5Error);
    s << indent << "relay6Error: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.relay6Error);
    s << indent << "relay7Error: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.relay7Error);
    s << indent << "relay8Error: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.relay8Error);
    s << indent << "servoMotor1: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.servoMotor1);
    s << indent << "servoMotor2: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.servoMotor2);
    s << indent << "servoMotor3: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.servoMotor3);
    s << indent << "servoMotor4: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.servoMotor4);
    s << indent << "mixingCamera: ";
    Printer<int8_t>::stream(s, indent + "  ", v.mixingCamera);
  }
};

} // namespace message_operations
} // namespace ros

#endif // ROS_ESSENTIALS_CPP_MESSAGE_CART_H
