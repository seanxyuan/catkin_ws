// Generated by gencpp from file ros_essentials_cpp/Delivery.msg
// DO NOT EDIT!


#ifndef ROS_ESSENTIALS_CPP_MESSAGE_DELIVERY_H
#define ROS_ESSENTIALS_CPP_MESSAGE_DELIVERY_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace ros_essentials_cpp
{
template <class ContainerAllocator>
struct Delivery_
{
  typedef Delivery_<ContainerAllocator> Type;

  Delivery_()
    : siloInputDoor(false)
    , siloConcreteLevel1(0)
    , siloConcreteLevel2(0)
    , siloBreaker(false)
    , siloDoser(false)
    , siloHopperLevel(false)
    , siloTrasmit(false)
    , towerLifting(0)
    , towerLiftError(false)
    , towerFunnelBreaker(false)
    , towerFunnelBreakerError(false)
    , towerAugerMotor1(false)
    , towerAugerMotor1Speed(0)
    , towerAugerMotor1Current(0)
    , towerAugerMotor1Torque(0)
    , towerAugerMotor2(false)
    , towerAugerMotor2Speed(0)
    , towerAugerMotor2Current(0)
    , towerAugerMotor2Torque(0)  {
    }
  Delivery_(const ContainerAllocator& _alloc)
    : siloInputDoor(false)
    , siloConcreteLevel1(0)
    , siloConcreteLevel2(0)
    , siloBreaker(false)
    , siloDoser(false)
    , siloHopperLevel(false)
    , siloTrasmit(false)
    , towerLifting(0)
    , towerLiftError(false)
    , towerFunnelBreaker(false)
    , towerFunnelBreakerError(false)
    , towerAugerMotor1(false)
    , towerAugerMotor1Speed(0)
    , towerAugerMotor1Current(0)
    , towerAugerMotor1Torque(0)
    , towerAugerMotor2(false)
    , towerAugerMotor2Speed(0)
    , towerAugerMotor2Current(0)
    , towerAugerMotor2Torque(0)  {
  (void)_alloc;
    }



   typedef uint8_t _siloInputDoor_type;
  _siloInputDoor_type siloInputDoor;

   typedef int8_t _siloConcreteLevel1_type;
  _siloConcreteLevel1_type siloConcreteLevel1;

   typedef int8_t _siloConcreteLevel2_type;
  _siloConcreteLevel2_type siloConcreteLevel2;

   typedef uint8_t _siloBreaker_type;
  _siloBreaker_type siloBreaker;

   typedef uint8_t _siloDoser_type;
  _siloDoser_type siloDoser;

   typedef uint8_t _siloHopperLevel_type;
  _siloHopperLevel_type siloHopperLevel;

   typedef uint8_t _siloTrasmit_type;
  _siloTrasmit_type siloTrasmit;

   typedef int8_t _towerLifting_type;
  _towerLifting_type towerLifting;

   typedef uint8_t _towerLiftError_type;
  _towerLiftError_type towerLiftError;

   typedef uint8_t _towerFunnelBreaker_type;
  _towerFunnelBreaker_type towerFunnelBreaker;

   typedef uint8_t _towerFunnelBreakerError_type;
  _towerFunnelBreakerError_type towerFunnelBreakerError;

   typedef uint8_t _towerAugerMotor1_type;
  _towerAugerMotor1_type towerAugerMotor1;

   typedef int8_t _towerAugerMotor1Speed_type;
  _towerAugerMotor1Speed_type towerAugerMotor1Speed;

   typedef int8_t _towerAugerMotor1Current_type;
  _towerAugerMotor1Current_type towerAugerMotor1Current;

   typedef int8_t _towerAugerMotor1Torque_type;
  _towerAugerMotor1Torque_type towerAugerMotor1Torque;

   typedef uint8_t _towerAugerMotor2_type;
  _towerAugerMotor2_type towerAugerMotor2;

   typedef int8_t _towerAugerMotor2Speed_type;
  _towerAugerMotor2Speed_type towerAugerMotor2Speed;

   typedef int8_t _towerAugerMotor2Current_type;
  _towerAugerMotor2Current_type towerAugerMotor2Current;

   typedef int8_t _towerAugerMotor2Torque_type;
  _towerAugerMotor2Torque_type towerAugerMotor2Torque;





  typedef boost::shared_ptr< ::ros_essentials_cpp::Delivery_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::ros_essentials_cpp::Delivery_<ContainerAllocator> const> ConstPtr;

}; // struct Delivery_

typedef ::ros_essentials_cpp::Delivery_<std::allocator<void> > Delivery;

typedef boost::shared_ptr< ::ros_essentials_cpp::Delivery > DeliveryPtr;
typedef boost::shared_ptr< ::ros_essentials_cpp::Delivery const> DeliveryConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::ros_essentials_cpp::Delivery_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::ros_essentials_cpp::Delivery_<ContainerAllocator> >::stream(s, "", v);
return s;
}

} // namespace ros_essentials_cpp

namespace ros
{
namespace message_traits
{



// BOOLTRAITS {'IsFixedSize': True, 'IsMessage': True, 'HasHeader': False}
// {'std_msgs': ['/opt/ros/melodic/share/std_msgs/cmake/../msg'], 'actionlib_msgs': ['/opt/ros/melodic/share/actionlib_msgs/cmake/../msg'], 'ros_essentials_cpp': ['/home/xy/catkin_ws/src/ros_essentials_cpp/msg', '/home/xy/catkin_ws/devel/share/ros_essentials_cpp/msg']}

// !!!!!!!!!!! ['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_parsed_fields', 'constants', 'fields', 'full_name', 'has_header', 'header_present', 'names', 'package', 'parsed_fields', 'short_name', 'text', 'types']




template <class ContainerAllocator>
struct IsFixedSize< ::ros_essentials_cpp::Delivery_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::ros_essentials_cpp::Delivery_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::ros_essentials_cpp::Delivery_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::ros_essentials_cpp::Delivery_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::ros_essentials_cpp::Delivery_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::ros_essentials_cpp::Delivery_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::ros_essentials_cpp::Delivery_<ContainerAllocator> >
{
  static const char* value()
  {
    return "7a84d7280a0d3509a502794110897fa1";
  }

  static const char* value(const ::ros_essentials_cpp::Delivery_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x7a84d7280a0d3509ULL;
  static const uint64_t static_value2 = 0xa502794110897fa1ULL;
};

template<class ContainerAllocator>
struct DataType< ::ros_essentials_cpp::Delivery_<ContainerAllocator> >
{
  static const char* value()
  {
    return "ros_essentials_cpp/Delivery";
  }

  static const char* value(const ::ros_essentials_cpp::Delivery_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::ros_essentials_cpp::Delivery_<ContainerAllocator> >
{
  static const char* value()
  {
    return "bool siloInputDoor\n"
"int8 siloConcreteLevel1\n"
"int8 siloConcreteLevel2\n"
"bool siloBreaker\n"
"bool siloDoser\n"
"bool siloHopperLevel\n"
"bool siloTrasmit\n"
"int8 towerLifting\n"
"bool towerLiftError\n"
"bool towerFunnelBreaker\n"
"bool towerFunnelBreakerError\n"
"bool towerAugerMotor1\n"
"int8 towerAugerMotor1Speed\n"
"int8 towerAugerMotor1Current\n"
"int8 towerAugerMotor1Torque\n"
"bool towerAugerMotor2\n"
"int8 towerAugerMotor2Speed\n"
"int8 towerAugerMotor2Current\n"
"int8 towerAugerMotor2Torque\n"
;
  }

  static const char* value(const ::ros_essentials_cpp::Delivery_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::ros_essentials_cpp::Delivery_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.siloInputDoor);
      stream.next(m.siloConcreteLevel1);
      stream.next(m.siloConcreteLevel2);
      stream.next(m.siloBreaker);
      stream.next(m.siloDoser);
      stream.next(m.siloHopperLevel);
      stream.next(m.siloTrasmit);
      stream.next(m.towerLifting);
      stream.next(m.towerLiftError);
      stream.next(m.towerFunnelBreaker);
      stream.next(m.towerFunnelBreakerError);
      stream.next(m.towerAugerMotor1);
      stream.next(m.towerAugerMotor1Speed);
      stream.next(m.towerAugerMotor1Current);
      stream.next(m.towerAugerMotor1Torque);
      stream.next(m.towerAugerMotor2);
      stream.next(m.towerAugerMotor2Speed);
      stream.next(m.towerAugerMotor2Current);
      stream.next(m.towerAugerMotor2Torque);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct Delivery_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::ros_essentials_cpp::Delivery_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::ros_essentials_cpp::Delivery_<ContainerAllocator>& v)
  {
    s << indent << "siloInputDoor: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.siloInputDoor);
    s << indent << "siloConcreteLevel1: ";
    Printer<int8_t>::stream(s, indent + "  ", v.siloConcreteLevel1);
    s << indent << "siloConcreteLevel2: ";
    Printer<int8_t>::stream(s, indent + "  ", v.siloConcreteLevel2);
    s << indent << "siloBreaker: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.siloBreaker);
    s << indent << "siloDoser: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.siloDoser);
    s << indent << "siloHopperLevel: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.siloHopperLevel);
    s << indent << "siloTrasmit: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.siloTrasmit);
    s << indent << "towerLifting: ";
    Printer<int8_t>::stream(s, indent + "  ", v.towerLifting);
    s << indent << "towerLiftError: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.towerLiftError);
    s << indent << "towerFunnelBreaker: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.towerFunnelBreaker);
    s << indent << "towerFunnelBreakerError: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.towerFunnelBreakerError);
    s << indent << "towerAugerMotor1: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.towerAugerMotor1);
    s << indent << "towerAugerMotor1Speed: ";
    Printer<int8_t>::stream(s, indent + "  ", v.towerAugerMotor1Speed);
    s << indent << "towerAugerMotor1Current: ";
    Printer<int8_t>::stream(s, indent + "  ", v.towerAugerMotor1Current);
    s << indent << "towerAugerMotor1Torque: ";
    Printer<int8_t>::stream(s, indent + "  ", v.towerAugerMotor1Torque);
    s << indent << "towerAugerMotor2: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.towerAugerMotor2);
    s << indent << "towerAugerMotor2Speed: ";
    Printer<int8_t>::stream(s, indent + "  ", v.towerAugerMotor2Speed);
    s << indent << "towerAugerMotor2Current: ";
    Printer<int8_t>::stream(s, indent + "  ", v.towerAugerMotor2Current);
    s << indent << "towerAugerMotor2Torque: ";
    Printer<int8_t>::stream(s, indent + "  ", v.towerAugerMotor2Torque);
  }
};

} // namespace message_operations
} // namespace ros

#endif // ROS_ESSENTIALS_CPP_MESSAGE_DELIVERY_H
